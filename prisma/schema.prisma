generator client {
  provider      = "prisma-client-js"
  output        = "/home/rizzo/bounty-website/node_modules/.prisma/client"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                String            @id @default(cuid())
  hotkey            String?           @unique
  username          String?           @unique
  email             String?           @unique
  walletAddress     String?
  password          String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  isActive          Boolean           @default(true)
  isAdmin           Boolean           @default(false)
  accounts          Account[]
  sessions          Session[]
  bounties          Bounty[]
  submissions       Submission[]
  suggestedBounties SuggestedBounty[]
  votes             Vote[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Bounty {
  id                      String                  @id @default(cuid())
  title                   String
  problem                 String                  // Short description of the problem
  info                    String                  // Technical details of how a submission is graded, file formats, etc
  requirements            String                  // Requirements for bounty completion
  rewardDistribution      RewardDistribution      @default(ALL_AT_ONCE)
  winningSpots            Int                     @default(1)
  status                  BountyStatus            @default(DRAFT)
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt
  deadline                DateTime?
  creatorId               String
  acceptedSubmissionTypes SubmissionContentType[] @default([FILE])
  creator                 User                    @relation(fields: [creatorId], references: [id])
  submissions             Submission[]
  suggestedBounty         SuggestedBounty?
  categories              BountyCategory[]        @relation("BountyToBountyCategory")
  screenerSupports        ScreenerBountySupport[]
  winningSpotConfigs      WinningSpot[]

  @@map("bounties")
}

model BountyCategory {
  id                String            @id @default(cuid())
  name              String            @unique
  color             String?
  createdAt         DateTime          @default(now())
  suggestedBounties SuggestedBounty[] @relation("BountyCategoryToSuggestedBounty")
  bounties          Bounty[]          @relation("BountyToBountyCategory")
  screenerSupports ScreenerBountySupport[]

  @@map("bounty_categories")
}

model Submission {
  id             String                @id @default(cuid())
  title          String
  description    String
  status         SubmissionStatus      @default(PENDING)
  score          Decimal?              @db.Decimal(5, 2)
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  validatedAt    DateTime?
  bountyId       String?
  submitterId    String
  suggestedBountyId String?
  contentType    SubmissionContentType @default(FILE)
  textContent    String?
  urls           String[]              @default([])
  tosAccepted    Boolean               @default(false)
  tosAcceptedAt  DateTime?
  files          SubmissionFile[]
  bounty         Bounty?               @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  suggestedBounty SuggestedBounty?     @relation(fields: [suggestedBountyId], references: [id], onDelete: Cascade)
  submitter      User                  @relation(fields: [submitterId], references: [id])
  validationLogs ValidationLog[]
  votes          Vote[]

  scoredBy     String[]     @default([]) // List of screener IDs that have scored this
  scoringJobs  ScoringJob[]

  @@map("submissions")
}

model SubmissionFile {
  id           String     @id @default(cuid())
  originalName String
  filename     String
  filepath     String
  filesize     BigInt
  mimeType     String
  fileType     FileType   @default(OTHER)
  uploadedAt   DateTime   @default(now())
  submissionId String
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@map("submission_files")
}

model Vote {
  id           String     @id @default(cuid())
  type         VoteType
  createdAt    DateTime   @default(now())
  userId       String
  submissionId String
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id])

  @@unique([userId, submissionId])
  @@map("votes")
}

model ValidationLog {
  id           String           @id @default(cuid())
  type         ValidationType
  result       ValidationResult @default(PENDING)
  score        Decimal?         @db.Decimal(5, 2)
  notes        String?
  validatorId  String?
  createdAt    DateTime         @default(now())
  submissionId String
  submission   Submission       @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@map("validation_logs")
}

model SuggestedBounty {
   id                      String                  @id @default(cuid())
  title                   String
  problem                 String                  // Short description of the problem
  info                    String                  // Technical details of how a submission is graded, file formats, etc
  requirements            String                  // Requirements for bounty completion
  rewardDistribution      RewardDistribution      @default(ALL_AT_ONCE)
  winningSpots            Int                     @default(1)
  status                  BountyStatus            @default(DRAFT)
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt
  deadline                DateTime?
  creatorId               String
  acceptedSubmissionTypes SubmissionContentType[] @default([FILE])
  creator                 User                    @relation(fields: [creatorId], references: [id])
  bounty                  Bounty?                 @relation(fields: [bountyId], references: [id])
  bountyId                String?                 @unique
  submissions             Submission[]
  categories              BountyCategory[]        @relation("BountyCategoryToSuggestedBounty")
  screenerSupports        ScreenerBountySupport[]
  winningSpotConfigs      WinningSpot[]

  @@map("suggested_bounties")
}

model Milestone {
  id          String          @id @default(cuid())
  title       String
  description String
  targetDate  DateTime?
  completed   Boolean         @default(false)
  completedAt DateTime?
  isPublic    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@map("milestones")
}

enum BountyStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum SuggestedBountyStatus {
  PENDING
  APPROVED
  REJECTED
}

enum RewardDistribution {
  ALL_AT_ONCE
  OVER_TIME
}

enum SubmissionContentType {
  URL
  FILE
  TEXT
  MIXED
}

enum SubmissionStatus {
  PENDING
  SCORING
  APPROVED
  REJECTED
  WINNER
}

enum FileType {
  DOCUMENT
  IMAGE
  VIDEO
  CODE
  ARCHIVE
  OTHER
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

enum ValidationType {
  AUTOMATED
  MANUAL
  COMMUNITY
}

enum ValidationResult {
  PASS
  FAIL
  PENDING
}


model Screener {
  id          String            @id @default(cuid())
  name        String            @unique
  hotkey      String            @unique
  apiUrl      String            // Base URL for the screener API
  isActive    Boolean           @default(true)
  priority    Int               @default(0) // Higher priority screeners are preferred
  maxConcurrent Int             @default(5) // Max concurrent scoring jobs
  currentJobs Int               @default(0) // Current active scoring jobs
  lastHeartbeat DateTime?       // Last heartbeat timestamp from screener
  heartbeatFailures Int         @default(0) // Consecutive heartbeat failures
  reportedRunningJobs String[]  @default([]) // Job IDs reported as running by screener
  lastJobReport DateTime?       // Last time screener reported job status
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  // Supported bounty categories and types
  supportedBounties ScreenerBountySupport[]
  scoringJobs       ScoringJob[]
  
  @@map("screeners")
}

model ScreenerBountySupport {
  id                String                  @id @default(cuid())
  screenerId        String
  bountyId          String?                 // Specific bounty support (optional)
  suggestedBountyId String?                 // Suggested bounty support (optional)
  categoryId        String?                 // Category-based support (optional)
  submissionTypes   SubmissionContentType[] // Supported submission types
  screener          Screener                @relation(fields: [screenerId], references: [id], onDelete: Cascade)
  bounty            Bounty?                 @relation(fields: [bountyId], references: [id])
  suggestedBounty   SuggestedBounty?        @relation(fields: [suggestedBountyId], references: [id])
  category          BountyCategory?         @relation(fields: [categoryId], references: [id])
  
  @@unique([screenerId, bountyId])
  @@unique([screenerId, suggestedBountyId])
  @@unique([screenerId, categoryId])
  @@map("screener_bounty_support")
}

model ScoringJob {
  id            String              @id @default(cuid())
  submissionId  String
  screenerId    String
  status        ScoringJobStatus    @default(PENDING)
  score         Decimal?            @db.Decimal(5, 2)
  startedAt     DateTime?
  completedAt   DateTime?
  errorMessage  String?
  retryCount    Int                 @default(0)
  maxRetries    Int                 @default(3)
  nextRetryAt   DateTime?           // When this job can be retried next
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  
  submission    Submission          @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  screener      Screener            @relation(fields: [screenerId], references: [id])
  
  @@unique([submissionId, screenerId])
  @@map("scoring_jobs")
}

enum ScoringJobStatus {
  PENDING
  ASSIGNED
  SCORING
  COMPLETED
  FAILED
  CANCELLED
}

model WinningSpot {
  id            String  @id @default(cuid())
  position      Int     // 1st, 2nd, 3rd place etc.
  reward        Decimal @db.Decimal(18, 8)
  rewardCap     Decimal @db.Decimal(18, 8)
  hotkey        String  // e.g., "1", "2", "3" or "F1", "F2", etc.
  createdAt     DateTime @default(now())
  bountyId      String?
  suggestedBountyId String?
  bounty        Bounty?          @relation(fields: [bountyId], references: [id], onDelete: Cascade)
  suggestedBounty SuggestedBounty? @relation(fields: [suggestedBountyId], references: [id], onDelete: Cascade)
  
  @@unique([bountyId, position])
  @@unique([bountyId, hotkey])
  @@unique([suggestedBountyId, position])
  @@unique([suggestedBountyId, hotkey])
  @@map("winning_spots")
}